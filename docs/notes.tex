\documentclass[11pt,a4paper]{article}
\usepackage[hscale=0.83,vscale=0.92]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{booktabs}
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\graphicspath{{./analysis/}}

\newcommand{\ord}{\textsuperscript{th} }
\newcommand{\code}[1]{\texttt{#1} }

\title{OTTER:\\OpenMP Task Tracer}
\begin{document}

\author{Adam Tuft}
\maketitle

\section{Introduction}

\section{OTTER Core}

OTTER Core implements the OMPT callbacks defined by the OMP runtime. It collects the data required to build the task graph and to record OTF2 locations, regions and events. OTTER Core defines various types used to store data relevant to corresponding OMP constructs such as parallel regions, threads, tasks etc.

OTTER Core defines the \code{scope\_t} type which enumerates the OMP constructs relevant to OTTER and the \code{region\_scope\_t} struct which contains data used to record entry into and exit from scopes. The scopes defined by OTTER are associated with OMP constructs which emit begin and end execution model events e.g. \code{scope\_parallel} is associated with parallel regions and their \emph{parallel-begin} and \emph{parallel-end} events.

The scopes enumerated by OTTER corresponding to OMP constructs that can be nested (e.g. parallel regions) are represented in the task graph by pairs of nodes (scope entry and exit nodes) which allows the nesting of OMP constructs to be reflected in the task graph. Those scopes representing standalone constructs (such as implicit barriers) are represented by single nodes generated during their \emph{scope-end} events.

The \code{region\_scope\_t} struct stores references to a scope's begin and end nodes as well as data used to identify the scope, a flag indicating whether the scope has encountered its \emph{scope-end} event and a stack storing references to the nodes created while a scope is active. It uses a mutex to ensure thread-safe updates of the scope.

A thread tracks the scope within which a callback occurs by maintaining a stack of \code{region\_scope\_t} structs. When a \emph{scope-begin} event is received, a thread pushes a reference to the new scope's struct onto its stack, which is then popped during the matching \emph{scope-end} event. Between a scope's begin and end events, a thread can inspect the innermost scope's data by examining the struct at the top of its stack. Scopes representing standalone constructs, such as barrier regions, do not use \code{region\_scope\_t} structs as they cannot be nested. Instead, their task graph node is created during their \emph{scope-end} events and added to the enclosing scope's stack of graph nodes.

In order for the graph nodes created during a scope to be connected to the scope's begin and end nodes, a scope records the nodes it encloses in a stack. When a node is added to the task graph it is also added to the innermost scope's node stack. During the \emph{scope-end} event a scope checks the nodes in its stack and adds an edge for each node with no immediate descendants. This ensures that all descendant nodes of the scope's begin node are ancestors of the scope's end node.

For standalone constructs that occur at the end of a region of code (e.g. implicit barriers) but before the \emph{scope-end} event of the enclosing scope, a node is added to the task graph and the procedure above used to connect all nodes in the enclosing scope to the standalone construct's node. During the \emph{scope-end} event of the standalone construct all nodes are removed from the node stack of the enclosing scope and replaced with a single reference to the standalone construct's node so that during the ensuing \emph{scope-end} event all nodes enclosed by the context except the node of the standalone context have immediate descendants. This ensures that standalone constructs such as synchronisation barriers are inserted correctly between a scope's end node and all nodes enclosed by the scope. This procedure occurs once in the thread that encountered the enclosing parallel region.

(Parallel region contexts and implicit-task-begin events - only encountering thread receices \emph{parallel-begin} and \emph{parallel-end} events but all participating threads need reference to the same parallel scope object = create scope in \emph{parallel-begin}, store in parallel data and retrieve during each thread's \emph{implicit-task-begin} event.)

(Joining consecutive scopes: a thread records the most recent scope added to/popped from its scope stack. A \emph{scope-end} followed by a \emph{scope-begin} means consecutive scopes.)



\section{Graph Data Structure}

OTTER uses a simple representation of a graph which allows addition of arbitrary nodes and directed edges. The graph is represented as a pair of queues; one for the nodes and another for the edges. A node is a struct containing an id, a type indicator, a pointer to arbitrary data and a flag to indicate whether it is the source of any edges. An edge is a struct with pointers to its start and end nodes.

Note that OTTER's graph implementation is very basic as it is not intended to be a general-purpose graph. For example, it does not support deletion of nodes or edges. It does support iterating over its nodes and edges with \code{graph\_scan\_nodes} and \code{graph\_scan\_edges}.

\section{OTTER Task Graph}

The task graph module manages the underlying graph data structure that represents the task graph of the OMP program. It manages a single global instance of a graph which is exposed to OTTER-core only through the \code{task\_graph\_} functions. The task graph is initialised once when OTTER starts (before the OMP program begins) and is destroyed when OTTER exits (after the OMP program is finished). Any other initialisation or destruction is an error. The task graph struct includes a mutex that is locked when a node or edge is added to ensure thread-safe updates of the task graph.

The module header defines the \code{task\_graph\_node\_type\_t} enum which lists the kinds of nodes that can be represented in the task graph. This enum is closely aligned to the \code{scope\_t} enum defined in \code{otter-core/otter.h} and is used to format the nodes when the task graph is saved.

Task graph output file name and format are controlled through environment variables. OTTER can save the task graph as a dot-file (.gv) or edge list (.csv).

\section{OTTER Trace}

To do...

\end{document}
